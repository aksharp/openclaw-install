apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Values.vaultServiceName }}-bootstrap
  namespace: {{ .Values.namespace }}
  labels:
    app.kubernetes.io/name: openclaw-bootstrap
    app.kubernetes.io/component: vault-bootstrap
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ .Values.vaultServiceName }}-bootstrap
  namespace: {{ .Values.namespace }}
  labels:
    app.kubernetes.io/name: openclaw-bootstrap
    app.kubernetes.io/component: vault-bootstrap
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "create", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ .Values.vaultServiceName }}-bootstrap
  namespace: {{ .Values.namespace }}
  labels:
    app.kubernetes.io/name: openclaw-bootstrap
    app.kubernetes.io/component: vault-bootstrap
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ .Values.vaultServiceName }}-bootstrap
subjects:
  - kind: ServiceAccount
    name: {{ .Values.vaultServiceName }}-bootstrap
    namespace: {{ .Values.namespace }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.vaultServiceName }}-auto-bootstrap
  namespace: {{ .Values.namespace }}
  labels:
    app.kubernetes.io/name: openclaw-bootstrap
    app.kubernetes.io/component: vault-bootstrap
spec:
  ttlSecondsAfterFinished: 300
  backoffLimit: 10
  template:
    metadata:
      labels:
        app.kubernetes.io/name: openclaw-bootstrap
        app.kubernetes.io/component: vault-bootstrap
    spec:
      serviceAccountName: {{ .Values.vaultServiceName }}-bootstrap
      restartPolicy: OnFailure
      volumes:
        - name: out
          emptyDir: {}
        - name: bootstrap-keys
          secret:
            secretName: {{ .Values.bootstrapKeysSecretName }}
            optional: true
      initContainers:
        - name: vault-init
          image: hashicorp/vault:latest
          imagePullPolicy: IfNotPresent
          command:
            - /bin/sh
            - -ec
            - |
              export VAULT_ADDR="http://{{ .Values.vaultServiceName }}:8200"
              echo "Waiting for Vault at $VAULT_ADDR..."
              OUT=""
              for i in $(seq 1 {{ .Values.vaultInitWaitLoops }}); do
                OUT=$(vault status 2>&1) || true
                if echo "$OUT" | grep -q "not initialized\|Sealed\|Initialized"; then break; fi
                [ "$i" -eq {{ .Values.vaultInitWaitLoops }} ] && { echo "Vault did not become ready"; exit 1; }
                sleep 2
              done
              if echo "$OUT" | grep -q "not initialized"; then
                echo "Initializing Vault..."
                vault operator init -key-shares=1 -key-threshold=1 2>&1 | tee /tmp/init.out
                grep "Unseal Key 1:" /tmp/init.out | sed 's/.*: *//' | tr -d '\r' > /out/unseal_key
                grep "Initial Root Token:" /tmp/init.out | sed 's/.*: *//' | tr -d '\r' > /out/root_token
              else
                echo "Vault already initialized, copying keys from Secret..."
                cp /vault-bootstrap-keys/root_token /out/root_token 2>/dev/null || true
                cp /vault-bootstrap-keys/unseal_key /out/unseal_key 2>/dev/null || true
                [ -s /out/root_token ] || { echo "Secret has no root_token"; exit 1; }
              fi
          env:
            - name: VAULT_ADDR
              value: "http://{{ .Values.vaultServiceName }}:8200"
          volumeMounts:
            - name: out
              mountPath: /out
            - name: bootstrap-keys
              mountPath: /vault-bootstrap-keys
              readOnly: true
      containers:
        - name: bootstrap
          image: alpine:3.19
          imagePullPolicy: IfNotPresent
          command:
            - /bin/sh
            - -ec
            - |
              set -e
              apk add --no-cache curl unzip ca-certificates
              ARCH=$(uname -m | sed 's/x86_64/amd64/;s/aarch64/arm64/')
              VAULT_VER=1.15.0
              curl -sSLo /tmp/vault.zip "https://releases.hashicorp.com/vault/${VAULT_VER}/vault_${VAULT_VER}_linux_${ARCH}.zip"
              unzip -o /tmp/vault.zip -d /usr/local/bin && chmod +x /usr/local/bin/vault
              curl -sSLo /usr/local/bin/kubectl "https://dl.k8s.io/release/v1.28.0/bin/linux/${ARCH}/kubectl" && chmod +x /usr/local/bin/kubectl

              export VAULT_ADDR="http://{{ .Values.vaultServiceName }}:8200"
              export VAULT_TOKEN="$(cat /out/root_token)"
              UNSEL_KEY="$(cat /out/unseal_key)"

              kubectl create secret generic {{ .Values.bootstrapKeysSecretName | quote }} \
                --from-file=unseal_key=/out/unseal_key --from-file=root_token=/out/root_token \
                -n "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -

              vault operator unseal "$UNSEL_KEY"
              vault secrets enable -path=openclaw kv-v2 2>/dev/null || true
              vault policy write openclaw-read - <<'POLICY'
              path "openclaw/data/*" { capabilities = ["read"] }
              path "openclaw/metadata/*" { capabilities = ["read"] }
              POLICY
              GATEWAY_TOKEN=$(vault token create -policy=openclaw-read -no-default-policy -field=client_token)
              kubectl create secret generic {{ .Values.gatewayTokenSecretName | quote }} \
                --from-literal=token="$GATEWAY_TOKEN" -n "${NAMESPACE}" \
                --dry-run=client -o yaml | kubectl apply -f -
              echo "Vault auto-bootstrap complete."
          env:
            - name: NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          volumeMounts:
            - name: out
              mountPath: /out
              readOnly: true
